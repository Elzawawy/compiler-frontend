# Parser Generator

PRSGEN is  *phase 2* of a **compiler frontend pipeline**. This work is done as the project for PLT (**P**rogramming **L**anguage **T**ranslation) course at Alexandria University, Faculty of Engineering Computer and Communications Department, offered in Spring 2020.

<p align='center'> Made with <b>love</b> :heart: and <b>hard work</b> :rocket:
<img src="./images/1.png"/>
</p>

**But, What's PARSE GEN really ?**

In our compiler model , the parser obtains a string of tokens from the lexical analyzer, and verifies that the string of token names can be generated by the grammar for the source language. We expect the parser to report any syntax errors in an intelligible fashion and to recover from commonly occurring errors to continue processing the remainder of the program.
Conceptually, for well-formed programs, the parser constructs a parse tree and passes it to the rest of the compiler for further processing.

<p align='center'><img src="./images/2.png"/></p>

**Goal of this phase ?**

- Aims to practice techniques for building automatic parser generator tools.
- Design and implement an LL (1) parser generator tool.

We begin the documentation of our PRSGEN by explaining the first component, the **grammar parser**, then we continue to explain the second component which is the **parsing table generator** and the third final component is the **predictive non-recursive parser**. In each component we explain what its goal and job exactly and then give a brief of how internally it works in a some what high level.

## Component One: Grammar Parser

The parser generator expects mainly an LL(1) grammar (CFG) as input but we also support elimination of left recursion and applying left factoring transformation.
Grammars were introduced in Section 2.2 from [1] to systematically describe the syntax of programming language constructs like expressions and statements.

A **context-free grammar** (will call just `grammar` from now on for short) consists of terminals, non-terminals, a start symbol, and productions.

### Terminals

Those are the basic symbols from which strings are formed. The token-name from lexical analyzer notation is a synonym for terminal here. We assume that the terminals are the first components of the tokens output by the lexical analyzer.


### Non-terminals

They are syntactic variables that denote sets of strings. The sets of strings denoted by non-terminals help define the language generated by the grammar. Non-terminals impose a hierarchical structure on the language that is key to syntax analysis and translation.

### Start Symbol

It is a distinguished non-terminal. Conventionally, the productions for the start symbol are listed first in the grammar rule.

### Productions

Specify the manner in which the terminals and non-terminals can be combined to form strings. It consists of:

- `Left side of the production`: non-terminal that is being defined by this production. 

- The arrow symbol `->` which is replaced sometimes with `::=` which is our case in our file format. 

- `Right side of the production`: consisting of zero or more terminals and non-terminals. The components of the body describe one way in which strings of the non-terminal at the head can be constructed.

<p align='center'><img src="./images/3.png"/></p>

### What is an LL(1) Grammar

Predictive parsers, that is, recursive-descent parsers needing no backtracking, can be constructed for a class of grammars called LL(1). The first `L` in LL(1) stands for scanning the input from left to right, the second `L` for producing a leftmost derivation, and the `1` for using one input symbol of lookahead at each step to make parsing action decisions.
The class of LL(1) grammars is rich enough to cover most programming constructs.

For any LL(1) grammar it should be,

- Un-ambiguous
- Non-left recursive
- left-factored

We did *extra work* on our PRSGEN to **support** removing the left recursion and applying left factoring transformation on grammar before calling other components.

### CFG Grammar Input File Format

- CFG input file is a `text` file.

- Production rules are lines in the form `LHS ::= RHS`

- Production rule can be expanded over many lines.

- Each Non terminal definition should start with `#`, and LHS should appear only once in the entire file.

- Terminal symbols are enclosed in single quotes.

- `\L` represents Lambda symbol.

- The symbol `|` is used in RHS of production rules to introduce more than one production for the same non terminal.

- Any reserved symbol needed to be used within the language, is preceded by an `\` escape backslash character.

### Implementation Details 

The Grammar Parser class has three main public methods to use.

- `parseFile(string file_path)` : which reads in the file contents and parses the grammar input into 2 data-structures that are used everywhere in the project later on.

- `eliminateLeftRecursion()` : which operates on the grammar input from file and eliminates the left recursion if any. This method have to be called after `parseFile` method is called and not before that.

- `applyLeftFactoring()` : which operates on the grammar input from file and apply left factoring transformation.This method have to be called after `parseFile` method is called and not before that.

The Grammar Parser owns the two data-structures that are used in the system throughout later on.

- `terminals_` : unordered_set of strings that contains all terminals found throughout the file.

- `non_terminals_` : vector of NonTerminal object that is found throughout the file with their production rules included inside each object.

## Component Two: Parsing Table Generator

## Component Three: Predictive Non-recursive Parser

---

## References

1. Compilers, Principles, Techniques, & Tools, Second Edition by Alfred V. Aho & Monica S. Lam & Ravi Sethi & Jeffrey D. Ullman

2. Engineering a Compiler, Second Edition by Keith D. Cooper & Linda Torczon.

---
